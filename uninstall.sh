#!/usr/bin/env bash
# This file is auto-generated by scripts/build.sh
# DO NOT EDIT - modify scripts/*.src.sh instead and run 'make buildscripts'
set -euo pipefail

# ── Inlined content from common.sh ──────────────────────────────────────────

# Color definitions - shared across all scripts
GRAY='\033[90m'
GREEN='\033[32m'
YELLOW='\033[33m'
RED='\033[31m'
BLUE='\033[34m'
RESET='\033[0m'

# Alternative name for compatibility
NC="$RESET"  # No Color (used in some scripts)

# Basic logging functions
log() { 
    echo -e "${GRAY}git-undo:${RESET} $1"
}

log_info() {
    echo -e "${BLUE}[INFO]${RESET} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${RESET} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${RESET} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${RESET} $*"
} 

# _get_script_dir determines the directory of this file (common.sh) in a POSIX-portable way
#
# Works when:
#   • the script is executed directly (`bash install.sh`)
#   • the script is sourced from another Bash script
#   • the outer shell is zsh (she-bang ensures Bash runs underneath)
_get_script_dir() {
    # $1 = one element of ${BASH_SOURCE[@]} or the zsh %x expansion
    local src="$1"
    while [ -h "$src" ]; do # Resolve symlinks if any
        local dir
        dir="$(cd -P -- "$(dirname -- "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ $src != /* ]] && src="$dir/$src"
    done

    # physical directory of the file itself
    local dir
    dir=$(cd -P -- "$(dirname -- "$src")" && pwd)
    # Because of how we store scripts: built executable scripts are in root
    # but helpers and sources are in `scripts` dir.
    # so always append scripts
    printf '%s/scripts' "$dir"
}

if [[ -n "${BASH_SOURCE[0]:-}" ]]; then               # Bash (she-bang path)
    SCRIPT_DIR="$(_get_script_dir "${BASH_SOURCE[0]}")"
else                                                  # POSIX sh execution
    SCRIPT_DIR="$(_get_script_dir "$0")"
fi
unset -f _get_script_dir

echo "SCRIPT DIR $SCRIPT_DIR"
# Coloring helpers

# Git-undo specific configuration
BIN_NAME="git-undo"
BIN_DIR=$(go env GOBIN 2>/dev/null || true)
[[ -z "$BIN_DIR" ]] && BIN_DIR="$(go env GOPATH)/bin"
BIN_PATH="$BIN_DIR/$BIN_NAME"

CFG_DIR="$HOME/.config/git-undo"
BASH_HOOK="$CFG_DIR/git-undo-hook.bash"
ZSH_HOOK="$CFG_DIR/git-undo-hook.zsh"
GIT_HOOKS_DIR="$CFG_DIR/hooks"
DISPATCHER_FILE="$GIT_HOOKS_DIR/git-hooks.sh"
DISPATCHER_SRC="$SCRIPT_DIR/git-undo-git-hook.sh"

REPO_OWNER="amberpixels"
REPO_NAME="git-undo"
GITHUB_REPO_URL="github.com/$REPO_OWNER/$REPO_NAME"
GITHUB_API_URL="https://api.github.com/repos/$REPO_OWNER/$REPO_NAME"
INSTALL_URL="https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/main/install.sh"

detect_shell() {
    # Method 1: Check $SHELL environment variable (most reliable for login shell)
    if [[ -n "$SHELL" ]]; then
        case "$SHELL" in
            *zsh*)
                echo "zsh"
                return
                ;;
            *bash*)
                echo "bash"
                return
                ;;
        esac
    fi

    # Method 2: Check shell-specific version variables
    if [[ -n "$ZSH_VERSION" ]]; then
        echo "zsh"
        return
    elif [[ -n "$BASH_VERSION" ]]; then
        echo "bash"
        return
    fi

    # If all methods fail
    echo "unknown"
}

get_latest_version() {
    local latest_release
    if command -v curl >/dev/null 2>&1; then
        latest_release=$(curl -s "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command -v wget >/dev/null 2>&1; then
        latest_release=$(wget -qO- "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    else
        echo "error: curl or wget required for version check" >&2
        return 1
    fi

    if [[ -z "$latest_release" || "$latest_release" == "null" ]]; then
        echo "error: failed to fetch latest version" >&2
        return 1
    fi

    echo "$latest_release"
}

version_compare() {
    local version1="$1"
    local version2="$2"

    # Remove 'v' prefix if present
    version1=${version1#v}
    version2=${version2#v}

    # Extract base version (everything before the first dash)
    local base1=$(echo "$version1" | cut -d'-' -f1)
    local base2=$(echo "$version2" | cut -d'-' -f1)

    # Convert base versions to comparable format (e.g., 1.2.3 -> 001002003)
    local v1=$(echo "$base1" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')
    local v2=$(echo "$base2" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')

    # Compare base versions first
    if [[ "$v1" < "$v2" ]]; then
        echo "older"
    elif [[ "$v1" > "$v2" ]]; then
        echo "newer"
    else
        # Base versions are the same, check for development version indicators
        # If one has additional info (date, commit, branch) and the other doesn't,
        # the one with additional info is newer
        if [[ "$version1" == "$base1" && "$version2" != "$base2" ]]; then
            # version1 is base tag, version2 is development version
            echo "older"
        elif [[ "$version1" != "$base1" && "$version2" == "$base2" ]]; then
            # version1 is development version, version2 is base tag
            echo "newer"
        else
            # Both are either base tags or both are development versions
            echo "same"
        fi
    fi
}

install_dispatcher_into() {
    local target="$1"

    # Validate target directory
    if [[ -z "$target" ]]; then
        log_error "Target directory not specified"
        return 1
    fi

    log "Installing git hooks into: $target"

    # Create target directory if it doesn't exist
    if ! mkdir -p "$target" 2>/dev/null; then
        log_error "Failed to create hooks directory: $target"
        return 1
    fi

    # 1) Install the dispatcher script only if target is our managed hooks directory
    if [[ "$target" == "$GIT_HOOKS_DIR" ]]; then
        log "Installing dispatcher script to: $DISPATCHER_FILE"

        # Debug: Check if source file exists
        echo "AAAA $DISPATCHER_SRC"
        if [[ ! -f "$DISPATCHER_SRC" ]]; then
            log_error "Source dispatcher script not found: $DISPATCHER_SRC"
            log_error "DISPATCHER_SRC variable: '$DISPATCHER_SRC'"
            log_error "Contents of script directory:"
            ls -la "$(dirname "$DISPATCHER_SRC")" 2>/dev/null || log_error "Cannot list script directory"
            return 1
        fi

        log "Source file exists: $DISPATCHER_SRC"
        log "Source file permissions: $(ls -l "$DISPATCHER_SRC")"

        # Ensure the hooks directory exists
        if ! mkdir -p "$GIT_HOOKS_DIR" 2>/dev/null; then
            log_error "Failed to create git hooks directory: $GIT_HOOKS_DIR"
            return 1
        fi

        log "Target directory exists: $GIT_HOOKS_DIR"
        log "Target directory permissions: $(ls -ld "$GIT_HOOKS_DIR")"

        # Try using cp instead of install command for better compatibility
        if cp "$DISPATCHER_SRC" "$DISPATCHER_FILE" 2>/dev/null; then
            chmod 755 "$DISPATCHER_FILE" 2>/dev/null || {
                log_error "Failed to set permissions on dispatcher script"
                return 1
            }
            log "Dispatcher copied and permissions set successfully"
        else
            log_error "Failed to copy dispatcher script from $DISPATCHER_SRC to $DISPATCHER_FILE"
            log_error "Let's try to understand why:"

            # More detailed debugging
            log_error "Source file readable? $(test -r "$DISPATCHER_SRC" && echo "YES" || echo "NO")"
            log_error "Target directory writable? $(test -w "$GIT_HOOKS_DIR" && echo "YES" || echo "NO")"
            log_error "Disk space available? $(df -h "$GIT_HOOKS_DIR" | tail -1)"

            return 1
        fi
    fi

    # 2) Wire up post-commit & post-merge hooks
    for hook in post-commit post-merge; do
        local hook_file="$target/$hook"
        log "Processing hook: $hook_file"

        if [[ -f "$hook_file" && ! -L "$hook_file" ]]; then
            # Existing regular file - append our hook call if not already present
            log "Found existing hook file, checking if git-undo is already integrated"

            if ! grep -q 'git-undo --hook' "$hook_file" 2>/dev/null; then
                log "Adding git-undo integration to existing hook"
                {
                    echo ""
                    echo "# git-undo integration"
                    echo "GIT_UNDO_INTERNAL_HOOK=1 git-undo --hook=\"$hook\""
                } >> "$hook_file"

                # Ensure it's executable
                chmod +x "$hook_file" 2>/dev/null || {
                    log_error "Failed to make hook executable: $hook_file"
                    return 1
                }
                log "Successfully integrated with existing $hook hook"
            else
                log "git-undo already integrated in $hook hook"
            fi

        elif [[ -L "$hook_file" ]]; then
            # It's a symlink - check if it points to our dispatcher
            local link_target
            link_target=$(readlink "$hook_file" 2>/dev/null || echo "")

            if [[ "$link_target" != "$DISPATCHER_FILE" ]]; then
                log_warning "Hook $hook_file is a symlink to $link_target, not our dispatcher"
                log "This hook may not work with git-undo"
            else
                log "Hook $hook_file already points to our dispatcher"
            fi

        else
            # No hook exists yet - create one
            log "Creating new $hook hook"

            # Try to create a symlink first (preferred method)
            if ln -sf "$DISPATCHER_FILE" "$hook_file" 2>/dev/null; then
                log "Created symlink: $hook_file -> $DISPATCHER_FILE"
            else
                # Fallback for filesystems that don't support symlinks
                log "Symlink failed, creating standalone hook script"
                cat > "$hook_file" << EOF
# git-undo hook - auto-generated
set -e
GIT_UNDO_INTERNAL_HOOK=1 git-undo --hook="$hook"
EOF
                chmod +x "$hook_file" 2>/dev/null || {
                    log_error "Failed to make hook executable: $hook_file"
                    return 1
                }
                log "Created standalone hook: $hook_file"
            fi
        fi
    done

    log "Hook installation completed for: $target"
    return 0
}
# ── End of inlined content ──────────────────────────────────────────────────

scrub_rc() {
    local rc="$1"
    [[ -e "$rc" ]] || return 1
    local real_rc="$rc"
    [[ -L "$rc" ]] && real_rc="$(readlink -f "$rc")"

    [[ -f "$real_rc" ]] || return 1

    # Check if hook line exists before attempting to remove it
    if ! grep -q "source .*git-undo-hook" "$real_rc" 2>/dev/null; then
        return 1  # No hook line found, nothing to do
    fi

    # Create backup only if we're going to modify the file
    cp "$real_rc" "${real_rc}.bak.$(date +%s)"

    # cross-platform sed in-place
    if sed --version &>/dev/null; then                    # GNU
        sed -i "/source .*git-undo-hook/d" "$real_rc"
    else                                                  # BSD / macOS
        sed -i '' "/source .*git-undo-hook/d" "$real_rc"
    fi
    return 0  # Successfully cleaned
}

main() {
    log "Starting uninstallation..."

    # 1) Remove binary
    echo -en "${GRAY}git-undo:${RESET} 1. Removing binary..."
    if [[ -f "$BIN_PATH" ]]; then
        rm -f "$BIN_PATH"
        echo -e " ${GREEN}OK${RESET}"
    else
        echo -e " ${YELLOW}SKIP${RESET} (not found)"
    fi

    # 2) Clean shell configuration files
    echo -en "${GRAY}git-undo:${RESET} 2. Cleaning shell configurations..."
    local cleaned_files=0

    # Check each rc file and count successful cleanings
    scrub_rc "$HOME/.zshrc" && ((cleaned_files++)) || true
    scrub_rc "$HOME/.bashrc" && ((cleaned_files++)) || true
    scrub_rc "$HOME/.bash_profile" && ((cleaned_files++)) || true

    if [ $cleaned_files -gt 0 ]; then
        echo -e " ${GREEN}OK${RESET} ($cleaned_files files)"
    else
        echo -e " ${YELLOW}SKIP${RESET} (no hook lines found)"
    fi

    # 3) Remove config directory
    echo -en "${GRAY}git-undo:${RESET} 3. Removing config directory..."
    if [[ -d "$CFG_DIR" ]]; then
        rm -rf "$CFG_DIR"
        echo -e " ${GREEN}OK${RESET}"
    else
        echo -e " ${YELLOW}SKIP${RESET} (not found)"
    fi

    # 4) Git hooks
    echo -en "${GRAY}git-undo:${RESET} 4. Cleaning git hooks…"
    if [[ "$(git config --global --get core.hooksPath)" == "$GIT_HOOKS_DIR" ]]; then
        git config --global --unset core.hooksPath
    fi

    for h in post-commit post-merge; do
        for dir in "$GIT_HOOKS_DIR" "$(git config --global --get core.hooksPath 2>/dev/null || true)"; do
            [[ -z "$dir" ]] && continue
            rm -f "$dir/$h"
        done
    done
    rm -f "$DISPATCHER_FILE"
    echo -e " ${GREEN}OK${RESET}"

    # 5) Final message
    log "${GREEN}Uninstallation completed successfully!${RESET}"
}

main "$@"
