#!/usr/bin/env bash
# This file is auto-generated by scripts/build.sh
# DO NOT EDIT - modify scripts/*.src.sh instead and run 'make buildscripts'
set -e

# ── Inlined content from common.sh ──────────────────────────────────────────

# Color definitions - shared across all scripts
GRAY='\033[90m'
GREEN='\033[32m'
YELLOW='\033[33m'
RED='\033[31m'
BLUE='\033[34m'
RESET='\033[0m'

# Alternative name for compatibility
NC="$RESET"  # No Color (used in some scripts)

# Basic logging functions
log() { 
    echo -e "${GRAY}git-undo:${RESET} $1"
}

log_info() {
    echo -e "${BLUE}[INFO]${RESET} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${RESET} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${RESET} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${RESET} $*"
} 


# Git-undo specific configuration
BIN_NAME="git-undo"
BIN_DIR=$(go env GOBIN 2>/dev/null || true)
[[ -z "$BIN_DIR" ]] && BIN_DIR="$(go env GOPATH)/bin"
BIN_PATH="$BIN_DIR/$BIN_NAME"

CFG_DIR="$HOME/.config/git-undo"
ZSH_HOOK="$CFG_DIR/git-undo-hook.zsh"
BASH_HOOK="$CFG_DIR/git-undo-hook.bash"
VERSION_FILE="$CFG_DIR/version"

REPO_OWNER="amberpixels"
REPO_NAME="git-undo"
GITHUB_API_URL="https://api.github.com/repos/$REPO_OWNER/$REPO_NAME"
INSTALL_URL="https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/main/install.sh"

detect_shell() {
    # Method 1: Check $SHELL environment variable (most reliable for login shell)
    if [[ -n "$SHELL" ]]; then
        case "$SHELL" in
            *zsh*)
                echo "zsh"
                return
                ;;
            *bash*)
                echo "bash"
                return
                ;;
        esac
    fi

    # Method 2: Check shell-specific version variables
    if [[ -n "$ZSH_VERSION" ]]; then
        echo "zsh"
        return
    elif [[ -n "$BASH_VERSION" ]]; then
        echo "bash"
        return
    fi

    # If all methods fail
    echo "unknown"
}

get_latest_version() {
    local latest_release
    if command -v curl >/dev/null 2>&1; then
        latest_release=$(curl -s "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command -v wget >/dev/null 2>&1; then
        latest_release=$(wget -qO- "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    else
        echo "error: curl or wget required for version check" >&2
        return 1
    fi
    
    if [[ -z "$latest_release" || "$latest_release" == "null" ]]; then
        echo "error: failed to fetch latest version" >&2
        return 1
    fi
    
    echo "$latest_release"
}

version_compare() {
    local version1="$1"
    local version2="$2"
    
    # Remove 'v' prefix if present
    version1=${version1#v}
    version2=${version2#v}
    
    # Extract base version (everything before the first dash)
    local base1=$(echo "$version1" | cut -d'-' -f1)
    local base2=$(echo "$version2" | cut -d'-' -f1)
    
    # Convert base versions to comparable format (e.g., 1.2.3 -> 001002003)
    local v1=$(echo "$base1" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')
    local v2=$(echo "$base2" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')
    
    # Compare base versions first
    if [[ "$v1" < "$v2" ]]; then
        echo "older"
    elif [[ "$v1" > "$v2" ]]; then
        echo "newer"
    else
        # Base versions are the same, check for development version indicators
        # If one has additional info (date, commit, branch) and the other doesn't, 
        # the one with additional info is newer
        if [[ "$version1" == "$base1" && "$version2" != "$base2" ]]; then
            # version1 is base tag, version2 is development version
            echo "older"
        elif [[ "$version1" != "$base1" && "$version2" == "$base2" ]]; then
            # version1 is development version, version2 is base tag
            echo "newer"
        else
            # Both are either base tags or both are development versions
            echo "same"
        fi
    fi
} 
# ── End of inlined content ──────────────────────────────────────────────────

main() {
    log "Checking for updates..."

    # 1) Get current version from the binary itself
    echo -en "${GRAY}git-undo:${RESET} 1. Current version..."
    local current_version
    if ! current_version=$(git-undo version 2>/dev/null | awk '{print $2}'); then
        echo -e " ${RED}FAILED${RESET}"
        log "Could not determine current version. Is git-undo installed?"
        exit 1
    fi
    
    if [[ -z "$current_version" || "$current_version" == "unknown" ]]; then
        echo -e " ${YELLOW}UNKNOWN${RESET}"
        log "No version information found. Reinstall git-undo."
        exit 1
    else
        echo -e " ${BLUE}$current_version${RESET}"
    fi

    # 2) Get latest release version
    echo -en "${GRAY}git-undo:${RESET} 2. Checking latest release..."
    local latest_version
    if ! latest_version=$(get_latest_version); then
        echo -e " ${RED}FAILED${RESET}"
        log "Failed to check latest version. Check your internet connection."
        exit 1
    fi
    echo -e " ${BLUE}$latest_version${RESET}"

    # 3) Compare versions
    echo -en "${GRAY}git-undo:${RESET} 3. Comparing releases..."
    local comparison
    comparison=$(version_compare "$current_version" "$latest_version")
    
    case "$comparison" in
        "same")
            echo -e " ${GREEN}UP TO DATE${RESET}"
            log "You're already running the latest release (${BLUE}$current_version${RESET})"
            exit 0
            ;;
        "newer")
            echo -e " ${YELLOW}NEWER${RESET}"
            log "You're running a newer release than available (${BLUE}$current_version${RESET} > ${BLUE}$latest_version${RESET})"
            exit 0
            ;;
        "older")
            echo -e " ${YELLOW}UPDATE AVAILABLE${RESET}"
            ;;
    esac

    # 4) Ask for confirmation
    echo -e ""
    echo -e "Update available: ${BLUE}$current_version${RESET} → ${GREEN}$latest_version${RESET}"
    echo -en "Do you want to update? [Y/n]: "
    read -r response
    
    case "$response" in
        [nN]|[nN][oO])
            log "Update cancelled."
            exit 0
            ;;
        *)
            ;;
    esac

    # 5) Download and run new installer
    echo -en "${GRAY}git-undo:${RESET} 4. Downloading latest installer..."
    local temp_installer
    temp_installer=$(mktemp)
    
    if command -v curl >/dev/null 2>&1; then
        if curl -sL "$INSTALL_URL" -o "$temp_installer"; then
            echo -e " ${GREEN}OK${RESET}"
        else
            echo -e " ${RED}FAILED${RESET}"
            rm -f "$temp_installer"
            exit 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -qO "$temp_installer" "$INSTALL_URL"; then
            echo -e " ${GREEN}OK${RESET}"
        else
            echo -e " ${RED}FAILED${RESET}"
            rm -f "$temp_installer"
            exit 1
        fi
    else
        echo -e " ${RED}FAILED${RESET}"
        log "curl or wget required for update"
        exit 1
    fi

    # 6) Run the installer
    echo -e ""
    log "Running installer..."
    chmod +x "$temp_installer"
    "$temp_installer"
    local install_status=$?
    rm -f "$temp_installer"

    if [[ $install_status -eq 0 ]]; then
        log "${GREEN}Update completed successfully!${RESET}"
        log "Updated to version ${GREEN}$latest_version${RESET}"
    else
        log "${RED}Update failed.${RESET}"
        exit 1
    fi
}

# Run main function
main "$@"
