#!/usr/bin/env bash
# This file is auto-generated by scripts/build.sh
# DO NOT EDIT - modify scripts/src/*.src.sh instead and run 'make buildscripts'

# ── Embedded hook files ── that's a base64 of scripts/git-undo-hook.bash ────
EMBEDDED_BASH_HOOK='IyBWYXJpYWJsZSB0byBzdG9yZSB0aGUgZ2l0IGNvbW1hbmQgdGVtcG9yYXJpbHkKR0lUX0NPTU1BTkRfVE9fTE9HPSIiCgojIEZ1bmN0aW9uIHRvIHN0b3JlIHRoZSBnaXQgY29tbWFuZCB0ZW1wb3JhcmlseQpzdG9yZV9naXRfY29tbWFuZCgpIHsKICBsb2NhbCByYXdfY21kPSIkMSIKICBsb2NhbCBoZWFkPSR7cmF3X2NtZCUlICp9CiAgbG9jYWwgcmVzdD0ke3Jhd19jbWQjIiRoZWFkIn0KCiAgIyBDaGVjayBpZiB0aGUgY29tbWFuZCBpcyBhbiBhbGlhcyBhbmQgZXhwYW5kIGl0CiAgaWYgYWxpYXMgIiRoZWFkIiAmPi9kZXYvbnVsbDsgdGhlbgogICAgbG9jYWwgZGVmCiAgICBkZWY9JChhbGlhcyAiJGhlYWQiKQogICAgIyBFeHRyYWN0IHRoZSBleHBhbnNpb24gZnJvbSBhbGlhcyBvdXRwdXQgKGZvcm1hdDogYWxpYXMgbmFtZT0nZXhwYW5zaW9uJykKICAgIGxvY2FsIGV4cGFuc2lvbj0ke2RlZiMqXCd9CiAgICBleHBhbnNpb249JHtleHBhbnNpb24lXCd9CiAgICByYXdfY21kPSIke2V4cGFuc2lvbn0ke3Jlc3R9IgogIGZpCgogICMgT25seSBzdG9yZSBpZiBpdCdzIGEgZ2l0IGNvbW1hbmQKICBbWyAiJHJhd19jbWQiID09IGdpdFwgKiBdXSB8fCByZXR1cm4KICBHSVRfQ09NTUFORF9UT19MT0c9IiRyYXdfY21kIgp9CgojIEZ1bmN0aW9uIHRvIGxvZyB0aGUgY29tbWFuZCBvbmx5IGlmIGl0IHdhcyBzdWNjZXNzZnVsCmxvZ19zdWNjZXNzZnVsX2dpdF9jb21tYW5kKCkgewogICMgQ2hlY2sgaWYgd2UgaGF2ZSBhIGdpdCBjb21tYW5kIHRvIGxvZyBhbmQgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwKICBpZiBbWyAtbiAiJEdJVF9DT01NQU5EX1RPX0xPRyIgJiYgJD8gLWVxIDAgXV07IHRoZW4KICAgIEdJVF9VTkRPX0lOVEVSTkFMX0hPT0s9MSBjb21tYW5kIGdpdC11bmRvIC0taG9vaz0iJEdJVF9DT01NQU5EX1RPX0xPRyIKICBmaQogICMgQ2xlYXIgdGhlIHN0b3JlZCBjb21tYW5kCiAgR0lUX0NPTU1BTkRfVE9fTE9HPSIiCn0KCiMgdHJhcCBkb2VzIHRoZSBhY3R1YWwgaG9va2luZzogbWFraW5nIGFuIGV4dHJhIGdpdC11bmRvIGNhbGwgZm9yIGV2ZXJ5IGdpdCBjb21tYW5kLgp0cmFwICdzdG9yZV9naXRfY29tbWFuZCAiJEJBU0hfQ09NTUFORCInIERFQlVHCgojIFNldCB1cCBQUk9NUFRfQ09NTUFORCB0byBsb2cgc3VjY2Vzc2Z1bCBjb21tYW5kcyBhZnRlciBleGVjdXRpb24KaWYgW1sgLXogIiRQUk9NUFRfQ09NTUFORCIgXV07IHRoZW4KICBQUk9NUFRfQ09NTUFORD0ibG9nX3N1Y2Nlc3NmdWxfZ2l0X2NvbW1hbmQiCmVsc2UKICBQUk9NUFRfQ09NTUFORD0iJFBST01QVF9DT01NQU5EOyBsb2dfc3VjY2Vzc2Z1bF9naXRfY29tbWFuZCIKZmk='
EMBEDDED_BASH_TEST_HOOK='IyBWYXJpYWJsZSB0byBzdG9yZSB0aGUgZ2l0IGNvbW1hbmQgdGVtcG9yYXJpbHkKR0lUX0NPTU1BTkRfVE9fTE9HPSIiCgojIEZ1bmN0aW9uIHRvIHN0b3JlIHRoZSBnaXQgY29tbWFuZCB0ZW1wb3JhcmlseQpzdG9yZV9naXRfY29tbWFuZCgpIHsKICBsb2NhbCByYXdfY21kPSIkMSIKICBsb2NhbCBoZWFkPSR7cmF3X2NtZCUlICp9CiAgbG9jYWwgcmVzdD0ke3Jhd19jbWQjIiRoZWFkIn0KCiAgIyBDaGVjayBpZiB0aGUgY29tbWFuZCBpcyBhbiBhbGlhcyBhbmQgZXhwYW5kIGl0CiAgaWYgYWxpYXMgIiRoZWFkIiAmPi9kZXYvbnVsbDsgdGhlbgogICAgbG9jYWwgZGVmCiAgICBkZWY9JChhbGlhcyAiJGhlYWQiKQogICAgIyBFeHRyYWN0IHRoZSBleHBhbnNpb24gZnJvbSBhbGlhcyBvdXRwdXQgKGZvcm1hdDogYWxpYXMgbmFtZT0nZXhwYW5zaW9uJykKICAgIGxvY2FsIGV4cGFuc2lvbj0ke2RlZiMqXCd9CiAgICBleHBhbnNpb249JHtleHBhbnNpb24lXCd9CiAgICByYXdfY21kPSIke2V4cGFuc2lvbn0ke3Jlc3R9IgogIGZpCgogICMgT25seSBzdG9yZSBpZiBpdCdzIGEgZ2l0IGNvbW1hbmQKICBbWyAiJHJhd19jbWQiID09IGdpdFwgKiBdXSB8fCByZXR1cm4KICBHSVRfQ09NTUFORF9UT19MT0c9IiRyYXdfY21kIgp9CgojIEZ1bmN0aW9uIHRvIGxvZyB0aGUgY29tbWFuZCBvbmx5IGlmIGl0IHdhcyBzdWNjZXNzZnVsCmxvZ19zdWNjZXNzZnVsX2dpdF9jb21tYW5kKCkgewogICMgQ2hlY2sgaWYgd2UgaGF2ZSBhIGdpdCBjb21tYW5kIHRvIGxvZyBhbmQgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwKICBpZiBbWyAtbiAiJEdJVF9DT01NQU5EX1RPX0xPRyIgJiYgJD8gLWVxIDAgXV07IHRoZW4KICAgIEdJVF9VTkRPX0lOVEVSTkFMX0hPT0s9MSBjb21tYW5kIGdpdC11bmRvIC0taG9vaz0iJEdJVF9DT01NQU5EX1RPX0xPRyIKICBmaQogICMgQ2xlYXIgdGhlIHN0b3JlZCBjb21tYW5kCiAgR0lUX0NPTU1BTkRfVE9fTE9HPSIiCn0KCgojIFRlc3QgbW9kZTogcHJvdmlkZSBhIG1hbnVhbCB3YXkgdG8gY2FwdHVyZSBjb21tYW5kcwojIFRoaXMgaXMgb25seSB1c2VkIGZvciBpbnRlZ3JhdGlvbi10ZXN0LmJhdHMuIApnaXQoKSB7CiAgICBjb21tYW5kIGdpdCAiJEAiCiAgICBsb2NhbCBleGl0X2NvZGU9JD8KICAgIGlmIFtbICRleGl0X2NvZGUgLWVxIDAgXV07IHRoZW4KICAgICAgICBHSVRfVU5ET19JTlRFUk5BTF9IT09LPTEgY29tbWFuZCBnaXQtdW5kbyAtLWhvb2s9ImdpdCAkKiIKICAgIGZpCiAgICByZXR1cm4gJGV4aXRfY29kZQp9CgoKIyBTZXQgdXAgUFJPTVBUX0NPTU1BTkQgdG8gbG9nIHN1Y2Nlc3NmdWwgY29tbWFuZHMgYWZ0ZXIgZXhlY3V0aW9uCmlmIFtbIC16ICIkUFJPTVBUX0NPTU1BTkQiIF1dOyB0aGVuCiAgUFJPTVBUX0NPTU1BTkQ9ImxvZ19zdWNjZXNzZnVsX2dpdF9jb21tYW5kIgplbHNlCiAgUFJPTVBUX0NPTU1BTkQ9IiRQUk9NUFRfQ09NTUFORDsgbG9nX3N1Y2Nlc3NmdWxfZ2l0X2NvbW1hbmQiCmZpCg=='
EMBEDDED_ZSH_HOOK='IyEvdXNyL2Jpbi9lbnYgenNoCiMgc2hlbGxjaGVjayBkaXNhYmxlPWFsbAojIEZ1bmN0aW9uIHRvIHN0b3JlIHRoZSBnaXQgY29tbWFuZCB0ZW1wb3JhcmlseQpzdG9yZV9naXRfY29tbWFuZCgpIHsKICBsb2NhbCByYXdfY21kPSIkMSIKICBsb2NhbCBoZWFkPSR7cmF3X2NtZCUlICp9CiAgbG9jYWwgcmVzdD0ke3Jhd19jbWQjIiRoZWFkIn0KICBpZiBhbGlhcyAiJGhlYWQiICY+L2Rldi9udWxsOyB0aGVuCiAgICBsb2NhbCBkZWYKICAgIGRlZj0kKGFsaWFzICIkaGVhZCIpCiAgICBsb2NhbCBleHBhbnNpb249JHtkZWYjKlwnfQogICAgZXhwYW5zaW9uPSR7ZXhwYW5zaW9uJVwnfQogICAgcmF3X2NtZD0iJHtleHBhbnNpb259JHtyZXN0fSIKICBmaQogIFtbICIkcmF3X2NtZCIgPT0gZ2l0XCAqIF1dIHx8IHJldHVybgogIEdJVF9DT01NQU5EX1RPX0xPRz0iJHJhd19jbWQiCn0KCiMgRnVuY3Rpb24gdG8gbG9nIHRoZSBjb21tYW5kIG9ubHkgaWYgaXQgd2FzIHN1Y2Nlc3NmdWwKbG9nX3N1Y2Nlc3NmdWxfZ2l0X2NvbW1hbmQoKSB7CiAgIyBDaGVjayBpZiB3ZSBoYXZlIGEgZ2l0IGNvbW1hbmQgdG8gbG9nIGFuZCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bAogIGlmIFtbIC1uICIkR0lUX0NPTU1BTkRfVE9fTE9HIiAmJiAkPyAtZXEgMCBdXTsgdGhlbgogICAgR0lUX1VORE9fSU5URVJOQUxfSE9PSz0xIGNvbW1hbmQgZ2l0LXVuZG8gLS1ob29rPSIkR0lUX0NPTU1BTkRfVE9fTE9HIgogIGZpCiAgIyBDbGVhciB0aGUgc3RvcmVkIGNvbW1hbmQKICBHSVRfQ09NTUFORF9UT19MT0c9IiIKfQoKYXV0b2xvYWQgLVUgYWRkLXpzaC1ob29rCmFkZC16c2gtaG9vayBwcmVleGVjIHN0b3JlX2dpdF9jb21tYW5kCmFkZC16c2gtaG9vayBwcmVjbWQgbG9nX3N1Y2Nlc3NmdWxfZ2l0X2NvbW1hbmQK'
# ── End of embedded hook files ──────────────────────────────────────────────

set -e

# Parse command line arguments
VERBOSE=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        *)
            shift
            ;;
    esac
done

# shellcheck disable=SC1091
# ── Inlined content from common.sh ──────────────────────────────────────────


# Color definitions - shared across all scripts
GRAY='\033[90m'
GREEN='\033[32m'
YELLOW='\033[33m'
RED='\033[31m'
BLUE='\033[34m'
NC='\033[0m'  # No Color

# Basic logging functions
log() { 
    echo -e "${GRAY}git-undo:${NC} $1"
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
} 

# _get_script_dir determines the directory of this file (common.sh) in a POSIX-portable way
#
# Works when:
#   • the script is executed directly (`bash install.sh`)
#   • the script is sourced from another Bash script
#   • the outer shell is zsh (she-bang ensures Bash runs underneath)
_get_script_dir() {
    # $1 = one element of ${BASH_SOURCE[@]} or the zsh %x expansion
    local src="$1"
    while [ -h "$src" ]; do # Resolve symlinks if any
        local dir
        dir="$(cd -P -- "$(dirname -- "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ $src != /* ]] && src="$dir/$src"
    done

    # physical directory of the file itself
    local dir
    dir=$(cd -P -- "$(dirname -- "$src")" && pwd)
    # Since common.sh is now in scripts/src/, we need to go up one level to get scripts/
    # Remove /src suffix if present, otherwise assume we're already in scripts/
    if [[ "$dir" == */src ]]; then
        printf '%s' "${dir%/src}"
    else
        printf '%s' "$dir"
    fi
}

if [[ -n "${BASH_SOURCE[0]:-}" ]]; then               # Bash (she-bang path)
    SCRIPT_DIR="$(_get_script_dir "${BASH_SOURCE[0]}")"
else                                                  # POSIX sh execution
    SCRIPT_DIR="$(_get_script_dir "$0")"
fi
unset -f _get_script_dir

echo "SCRIPT DIR $SCRIPT_DIR"
# Coloring helpers
# shellcheck disable=SC1091

# Git-undo specific configuration
UNDO_BIN_NAME="git-undo"
BACK_BIN_NAME="git-back"
BIN_DIR=$(go env GOBIN 2>/dev/null || true)
[[ -z "$BIN_DIR" ]] && BIN_DIR="$(go env GOPATH)/bin"
export UNDO_BIN_PATH="$BIN_DIR/$UNDO_BIN_NAME"
export BACK_BIN_PATH="$BIN_DIR/$BACK_BIN_NAME"

# Legacy variable for backward compatibility
export BIN_PATH="$UNDO_BIN_PATH"

CFG_DIR="$HOME/.config/git-undo"
export BASH_HOOK="$CFG_DIR/git-undo-hook.bash"
export ZSH_HOOK="$CFG_DIR/git-undo-hook.zsh"
GIT_HOOKS_DIR="$CFG_DIR/hooks"
DISPATCHER_FILE="$GIT_HOOKS_DIR/git-hooks.sh"
DISPATCHER_SRC="$SCRIPT_DIR/scripts/git-undo-git-hook.sh"

REPO_OWNER="amberpixels"
REPO_NAME="git-undo"
export GITHUB_REPO_URL="github.com/$REPO_OWNER/$REPO_NAME"
GITHUB_API_URL="https://api.github.com/repos/$REPO_OWNER/$REPO_NAME"
export INSTALL_URL="https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/main/install.sh"

detect_shell() {
    # Method 1: Check $SHELL environment variable (most reliable for login shell)
    if [[ -n "$SHELL" ]]; then
        case "$SHELL" in
            *zsh*)
                echo "zsh"
                return
                ;;
            *bash*)
                echo "bash"
                return
                ;;
        esac
    fi

    # Method 2: Check shell-specific version variables
    if [[ -n "$ZSH_VERSION" ]]; then
        echo "zsh"
        return
    elif [[ -n "$BASH_VERSION" ]]; then
        echo "bash"
        return
    fi

    # If all methods fail
    echo "unknown"
}

get_latest_version() {
    local latest_release
    if command -v curl >/dev/null 2>&1; then
        latest_release=$(curl -s "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command -v wget >/dev/null 2>&1; then
        latest_release=$(wget -qO- "$GITHUB_API_URL/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    else
        echo "error: curl or wget required for version check" >&2
        return 1
    fi

    if [[ -z "$latest_release" || "$latest_release" == "null" ]]; then
        echo "error: failed to fetch latest version" >&2
        return 1
    fi

    echo "$latest_release"
}

version_compare() {
    local version1="$1"
    local version2="$2"

    # Remove 'v' prefix if present
    version1=${version1#v}
    version2=${version2#v}

    # Extract base version (everything before the first dash)
    local base1
    local base2
    base1=$(echo "$version1" | cut -d'-' -f1)
    base2=$(echo "$version2" | cut -d'-' -f1)

    # Convert base versions to comparable format (e.g., 1.2.3 -> 001002003)
    local v1
    local v2
    v1=$(echo "$base1" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')
    v2=$(echo "$base2" | awk -F. '{ printf("%03d%03d%03d\n", $1, $2, $3); }')

    # Compare base versions first
    if [[ "$v1" < "$v2" ]]; then
        echo "older"
    elif [[ "$v1" > "$v2" ]]; then
        echo "newer"
    else
        # Base versions are the same, check for development version indicators
        # If one has additional info (date, commit, branch) and the other doesn't,
        # the one with additional info is newer
        if [[ "$version1" == "$base1" && "$version2" != "$base2" ]]; then
            # version1 is base tag, version2 is development version
            echo "older"
        elif [[ "$version1" != "$base1" && "$version2" == "$base2" ]]; then
            # version1 is development version, version2 is base tag
            echo "newer"
        else
            # Both are either base tags or both are development versions
            echo "same"
        fi
    fi
}

install_dispatcher_into() {
    local target="$1"

    # Validate target directory
    if [[ -z "$target" ]]; then
        log_error "Target directory not specified"
        return 1
    fi

    log "Installing git hooks into: $target"

    # Create target directory if it doesn't exist
    if ! mkdir -p "$target" 2>/dev/null; then
        log_error "Failed to create hooks directory: $target"
        return 1
    fi

    # 1) Install the dispatcher script only if target is our managed hooks directory
    if [[ "$target" == "$GIT_HOOKS_DIR" ]]; then
        log "Installing dispatcher script to: $DISPATCHER_FILE"

        # Debug: Check if source file exists
        echo "AAAA $DISPATCHER_SRC"
        if [[ ! -f "$DISPATCHER_SRC" ]]; then
            log_error "Source dispatcher script not found: $DISPATCHER_SRC"
            log_error "DISPATCHER_SRC variable: '$DISPATCHER_SRC'"
            log_error "Contents of script directory:"
            ls -la "$(dirname "$DISPATCHER_SRC")" 2>/dev/null || log_error "Cannot list script directory"
            return 1
        fi

        log "Source file exists: $DISPATCHER_SRC"
        log "Source file permissions: $(ls -l "$DISPATCHER_SRC")"

        # Ensure the hooks directory exists
        if ! mkdir -p "$GIT_HOOKS_DIR" 2>/dev/null; then
            log_error "Failed to create git hooks directory: $GIT_HOOKS_DIR"
            return 1
        fi

        log "Target directory exists: $GIT_HOOKS_DIR"
        log "Target directory permissions: $(ls -ld "$GIT_HOOKS_DIR")"

        # Try using cp instead of install command for better compatibility
        if cp "$DISPATCHER_SRC" "$DISPATCHER_FILE" 2>/dev/null; then
            chmod 755 "$DISPATCHER_FILE" 2>/dev/null || {
                log_error "Failed to set permissions on dispatcher script"
                return 1
            }
            log "Dispatcher copied and permissions set successfully"
        else
            log_error "Failed to copy dispatcher script from $DISPATCHER_SRC to $DISPATCHER_FILE"
            log_error "Let's try to understand why:"

            # More detailed debugging
            log_error "Source file readable? $(test -r "$DISPATCHER_SRC" && echo "YES" || echo "NO")"
            log_error "Target directory writable? $(test -w "$GIT_HOOKS_DIR" && echo "YES" || echo "NO")"
            log_error "Disk space available? $(df -h "$GIT_HOOKS_DIR" | tail -1)"

            return 1
        fi
    fi

    # 2) Wire up post-commit & post-merge hooks
    for hook in post-commit post-merge; do
        local hook_file="$target/$hook"
        log "Processing hook: $hook_file"

        if [[ -f "$hook_file" && ! -L "$hook_file" ]]; then
            # Existing regular file - append our hook call if not already present
            log "Found existing hook file, checking if git-undo is already integrated"

            if ! grep -q 'git-undo --hook' "$hook_file" 2>/dev/null; then
                log "Adding git-undo integration to existing hook"
                {
                    echo ""
                    echo "# git-undo integration"
                    echo "GIT_UNDO_INTERNAL_HOOK=1 git-undo --hook=\"$hook\""
                } >> "$hook_file"

                # Ensure it's executable
                chmod +x "$hook_file" 2>/dev/null || {
                    log_error "Failed to make hook executable: $hook_file"
                    return 1
                }
                log "Successfully integrated with existing $hook hook"
            else
                log "git-undo already integrated in $hook hook"
            fi

        elif [[ -L "$hook_file" ]]; then
            # It's a symlink - check if it points to our dispatcher
            local link_target
            link_target=$(readlink "$hook_file" 2>/dev/null || echo "")

            if [[ "$link_target" != "$DISPATCHER_FILE" ]]; then
                log_warning "Hook $hook_file is a symlink to $link_target, not our dispatcher"
                log "This hook may not work with git-undo"
            else
                log "Hook $hook_file already points to our dispatcher"
            fi

        else
            # No hook exists yet - create one
            log "Creating new $hook hook"

            # Try to create a symlink first (preferred method)
            if ln -sf "$DISPATCHER_FILE" "$hook_file" 2>/dev/null; then
                log "Created symlink: $hook_file -> $DISPATCHER_FILE"
            else
                # Fallback for filesystems that don't support symlinks
                log "Symlink failed, creating standalone hook script"
                cat > "$hook_file" << EOF
# git-undo hook - auto-generated
set -e
GIT_UNDO_INTERNAL_HOOK=1 git-undo --hook="$hook"
EOF
                chmod +x "$hook_file" 2>/dev/null || {
                    log_error "Failed to make hook executable: $hook_file"
                    return 1
                }
                log "Created standalone hook: $hook_file"
            fi
        fi
    done

    log "Hook installation completed for: $target"
    return 0
}

# ── End of inlined content ──────────────────────────────────────────────────

# Verbose logging function
verbose_log() {
    if $VERBOSE; then
        echo -e "${GRAY}[VERBOSE]${NC} $1"
    fi
}

# Function to write an embedded hook file
write_embedded_hook() {
    local target_file="$1"
    local embedded_var="$2"

    verbose_log "Writing embedded hook file: $target_file"
    # Decode the base64 embedded content and write it to the target file
    if echo "${!embedded_var}" | base64 -d > "$target_file" 2>/dev/null; then
        verbose_log "Successfully wrote hook file: $target_file"
    else
        verbose_log "Failed to write hook file: $target_file"
        return 1
    fi
    
    if chmod 644 "$target_file" 2>/dev/null; then
        verbose_log "Successfully set permissions on: $target_file"
    else
        verbose_log "Failed to set permissions on: $target_file"
        return 1
    fi
    return 0
}

install_shell_hook() {
    local shell_type="$1"
    local is_noop=true

    verbose_log "Installing shell hook for: $shell_type"
    
    # Create config directory with proper permissions
    if [ ! -d "$CFG_DIR" ]; then
        verbose_log "Creating config directory: $CFG_DIR"
        if mkdir -p "$CFG_DIR" 2>/dev/null; then
            verbose_log "Successfully created config directory"
        else
            verbose_log "Failed to create config directory: $CFG_DIR"
            return 1
        fi
        
        if chmod 755 "$CFG_DIR" 2>/dev/null; then
            verbose_log "Successfully set permissions on config directory"
        else
            verbose_log "Failed to set permissions on config directory"
            return 1
        fi
        is_noop=false
    else
        verbose_log "Config directory already exists: $CFG_DIR"
    fi

    case "$shell_type" in
        "zsh")
            local rc_file="$HOME/.zshrc"
            local source_line="source ~/.config/git-undo/git-undo-hook.zsh"

            verbose_log "Processing zsh hook installation"
            verbose_log "RC file: $rc_file"
            verbose_log "Hook file: $ZSH_HOOK"
            
            # Write the embedded hook file
            if [ ! -f "$ZSH_HOOK" ]; then
                verbose_log "Hook file doesn't exist, creating it"
                if write_embedded_hook "$ZSH_HOOK" "EMBEDDED_ZSH_HOOK"; then
                    verbose_log "Successfully created zsh hook file"
                    is_noop=false
                else
                    verbose_log "Failed to create zsh hook file"
                    return 1
                fi
            else
                verbose_log "Hook file already exists: $ZSH_HOOK"
            fi

            # Add source line to .zshrc if not already present
            if ! grep -qxF "$source_line" "$rc_file" 2>/dev/null; then
                verbose_log "Adding source line to $rc_file"
                if echo "$source_line" >> "$rc_file" 2>/dev/null; then
                    verbose_log "Successfully added source line to $rc_file"
                    is_noop=false
                else
                    verbose_log "Failed to add source line to $rc_file"
                    return 1
                fi
            else
                verbose_log "Source line already exists in $rc_file"
            fi
            ;;

        "bash")
            local source_line="source ~/.config/git-undo/git-undo-hook.bash"

            verbose_log "Processing bash hook installation"
            
            # Determine which embedded hook to use
            local embedded_var="EMBEDDED_BASH_HOOK"
            if [[ "${GIT_UNDO_TEST_MODE:-}" == "true" ]]; then
                embedded_var="EMBEDDED_BASH_TEST_HOOK"
                verbose_log "Using test mode bash hook"
            fi
            verbose_log "Using embedded variable: $embedded_var"
            verbose_log "Hook file: $BASH_HOOK"

            # Write the embedded hook file
            if [ ! -f "$BASH_HOOK" ]; then
                verbose_log "Hook file doesn't exist, creating it"
                if write_embedded_hook "$BASH_HOOK" "$embedded_var"; then
                    verbose_log "Successfully created bash hook file"
                    is_noop=false
                else
                    verbose_log "Failed to create bash hook file"
                    return 1
                fi
            else
                verbose_log "Hook file already exists: $BASH_HOOK"
            fi

            # Determine which bash config file to use
            local rc_file
            if [[ "$OSTYPE" == "darwin"* ]]; then
                # macOS uses .bash_profile for login shells (default in Terminal.app)
                rc_file="$HOME/.bash_profile"
                verbose_log "macOS detected, using .bash_profile"
            else
                # Linux typically uses .bashrc for interactive shells
                rc_file="$HOME/.bashrc"
                verbose_log "Linux detected, using .bashrc"
            fi
            verbose_log "RC file: $rc_file"

            # Add source line to the appropriate file if not already present
            if ! grep -qxF "$source_line" "$rc_file" 2>/dev/null; then
                verbose_log "Adding source line to $rc_file"
                if echo "$source_line" >> "$rc_file" 2>/dev/null; then
                    verbose_log "Successfully added source line to $rc_file"
                    is_noop=false
                else
                    verbose_log "Failed to add source line to $rc_file"
                    return 1
                fi
            else
                verbose_log "Source line already exists in $rc_file"
            fi
            ;;

        *)
            return 1
            ;;
    esac

    # Return 2 if no changes were made (already installed)
    if $is_noop; then
        return 2
    fi
    return 0
}

main() {
    log "Starting installation..."
    verbose_log "Verbose mode enabled"

    local skip_binary=false
    local detected_go="go-unknown"

    verbose_log "Checking for Go installation..."
    if ! command -v go >/dev/null 2>&1; then
        verbose_log "Go command not found in PATH"
        echo -e "${GRAY}git-undo:${NC} 1. Installing Go binary... ${RED}FAILED${NC} Go not found. ${RED}Go 1.22+ is required to build the binary.${NC}"
        skip_binary=true
    else
        verbose_log "Go found, checking version..."
        # Extract major & minor (works for go1.xx and goX.YY)
        local ver_raw ver_major ver_minor
        ver_raw=$(go version | awk '{print $3}')       # e.g. go1.22.1
        ver_major=$(printf '%s\n' "$ver_raw" | sed -E 's/go([0-9]+).*/\1/')
        ver_minor=$(printf '%s\n' "$ver_raw" | sed -E 's/go[0-9]+\.([0-9]+).*/\1/')
        detected_go="$ver_raw"
        
        verbose_log "Detected Go version: $ver_raw (major: $ver_major, minor: $ver_minor)"

        if  (( ver_major < 1 )) || { (( ver_major == 1 )) && (( ver_minor < 22 )); }; then
            verbose_log "Go version is too old (< 1.22)"
            echo -e "${GRAY}git-undo:${NC} 1. Installing Go binary... ${RED}FAILED${NC} Detected Go ${YELLOW}${ver_raw}${NC}, but Go ${RED}≥ 1.22${NC} is required."
            skip_binary=true
        else
            verbose_log "Go version is acceptable (>= 1.22)"
        fi
    fi

    if ! $skip_binary; then
         verbose_log "Proceeding with binary installation"
         # 1) Install the binaries
         echo -en "${GRAY}git-undo:${NC} 1. Installing Go binaries (${BLUE}${detected_go}${NC}) ..."

         # Check if we're in dev mode with local source available
         if [[ "${GIT_UNDO_DEV_MODE:-}" == "true" && -d "./cmd/git-undo" && -f "./Makefile" ]]; then
             echo -e " ${YELLOW}(dev mode)${NC}"
             verbose_log "Dev mode detected, building from local source"
             log "Building from local source using Makefile..."

             # Use Makefile's binary-install target which has proper version logic
             verbose_log "Running 'make binary-install'..."
             if $VERBOSE; then
                 # Run with output visible in verbose mode
                 if make binary-install; then
                     verbose_log "make binary-install succeeded"
                     # Get the version that was just installed
                     INSTALLED_VERSION=$(git-undo --version 2>/dev/null  || echo "unknown")
                     echo -e "${GRAY}git-undo:${NC} Binaries installed with version: ${BLUE}$INSTALLED_VERSION${NC}"
                     log "Installed: git-undo and git-back"
                 else
                     verbose_log "make binary-install failed"
                     echo -e "${GRAY}git-undo:${NC} ${RED}Failed to build from source using Makefile${NC}"
                     exit 1
                 fi
             else
                 # Run silently in non-verbose mode
                 if make binary-install &>/dev/null; then
                     verbose_log "make binary-install succeeded"
                     # Get the version that was just installed
                     INSTALLED_VERSION=$(git-undo --version 2>/dev/null  || echo "unknown")
                     echo -e "${GRAY}git-undo:${NC} Binaries installed with version: ${BLUE}$INSTALLED_VERSION${NC}"
                     log "Installed: git-undo and git-back"
                 else
                     verbose_log "make binary-install failed"
                     echo -e "${GRAY}git-undo:${NC} ${RED}Failed to build from source using Makefile${NC}"
                     exit 1
                 fi
             fi
         else
             verbose_log "Normal installation mode from GitHub"
             # Normal user installation from GitHub - install both binaries
             local undo_failed=false
             local back_failed=false
             
             verbose_log "Installing git-undo from $GITHUB_REPO_URL/cmd/$UNDO_BIN_NAME@latest"
             # Install git-undo (required)
             if $VERBOSE; then
                 if ! go install "$GITHUB_REPO_URL/cmd/$UNDO_BIN_NAME@latest"; then
                     verbose_log "git-undo installation failed"
                     undo_failed=true
                 else
                     verbose_log "git-undo installation succeeded"
                 fi
             else
                 if ! go install "$GITHUB_REPO_URL/cmd/$UNDO_BIN_NAME@latest" 2>/dev/null; then
                     verbose_log "git-undo installation failed"
                     undo_failed=true
                 else
                     verbose_log "git-undo installation succeeded"
                 fi
             fi
             
             # If git-undo failed, that's a critical error
             if $undo_failed; then
                 verbose_log "git-undo installation failed - this is required"
                 echo -e " ${RED}FAILED${NC} (git-undo installation failed)"
                 exit 1
             fi
             
             verbose_log "Installing git-back from $GITHUB_REPO_URL/cmd/$BACK_BIN_NAME@latest"
             # Install git-back (optional)
             if $VERBOSE; then
                 if ! go install "$GITHUB_REPO_URL/cmd/$BACK_BIN_NAME@latest"; then
                     verbose_log "git-back installation failed - continuing without it"
                     back_failed=true
                 else
                     verbose_log "git-back installation succeeded"
                 fi
             else
                 if ! go install "$GITHUB_REPO_URL/cmd/$BACK_BIN_NAME@latest" 2>/dev/null; then
                     verbose_log "git-back installation failed - continuing without it"
                     back_failed=true
                 else
                     verbose_log "git-back installation succeeded"
                 fi
             fi
             
             # Success message based on what was installed
             UNDO_BIN_PATH=$(command -v git-undo || echo "$BIN_DIR/$UNDO_BIN_NAME")
             INSTALLED_VERSION=$(git-undo --version 2>/dev/null  || echo "unknown")
             verbose_log "git-undo path: $UNDO_BIN_PATH"
             verbose_log "Installed version: $INSTALLED_VERSION"
             
             if $back_failed; then
                 verbose_log "git-back installation failed, but git-undo succeeded"
                 echo -e " ${YELLOW}PARTIAL${NC} (git-undo: ${BLUE}${UNDO_BIN_PATH}${NC} | version=${BLUE}${INSTALLED_VERSION}${NC})"
                 log "${YELLOW}Warning: git-back could not be installed (not available in this version). Only git-undo is available.${NC}"
             else
                 BACK_BIN_PATH=$(command -v git-back || echo "$BIN_DIR/$BACK_BIN_NAME")
                 verbose_log "git-back path: $BACK_BIN_PATH"
                 verbose_log "All binary installations succeeded"
                 echo -e " ${GREEN}OK${NC} (git-undo: ${BLUE}${UNDO_BIN_PATH}${NC}, git-back: ${BLUE}${BACK_BIN_PATH}${NC} | version=${BLUE}${INSTALLED_VERSION}${NC})"
             fi
         fi
    else
        verbose_log "Skipping binary installation due to Go issues"
    fi

    # 2) Git hooks integration
    echo -en "${GRAY}git-undo:${NC} 2. Git integration..."
    verbose_log "Starting git hooks integration"

    current_hooks_path=$(git config --global --get core.hooksPath || echo "")
    target_hooks_path="$GIT_HOOKS_DIR"
    
    verbose_log "Current global hooks path: '${current_hooks_path}'"
    verbose_log "Target hooks path: '${target_hooks_path}'"

    if [[ -z "$current_hooks_path" ]]; then
        verbose_log "No global hooks path set, configuring our hooks path"
        if git config --global core.hooksPath "$target_hooks_path"; then
            verbose_log "Successfully set global core.hooksPath to $target_hooks_path"
        else
            verbose_log "Failed to set global core.hooksPath"
        fi
        
        verbose_log "Installing dispatcher into $target_hooks_path"
        install_dispatcher_into "$target_hooks_path"
        echo -e " ${GREEN}OK${NC} (set core.hooksPath)"
    elif [[ "$current_hooks_path" == "$target_hooks_path" ]]; then
        verbose_log "Hooks path already configured correctly"
        verbose_log "Installing dispatcher into $target_hooks_path"
        install_dispatcher_into "$target_hooks_path"
        echo -e " ${YELLOW}SKIP${NC} (already configured)"
    else
        verbose_log "Different hooks path already configured, piggybacking on it"
        verbose_log "Installing dispatcher into existing path: $current_hooks_path"
        install_dispatcher_into "$current_hooks_path"
        echo -e " ${YELLOW}SHARED${NC} (pig-backed on $current_hooks_path)"
    fi

    # 3) Shell integration
    verbose_log "Starting shell integration"
    local current_shell
    current_shell=$(detect_shell)
    verbose_log "Detected shell: $current_shell"
    echo -en "${GRAY}git-undo:${NC} 3. Shell integration (${BLUE}$current_shell${NC})..."

    # Temporarily disable set -e to capture non-zero exit codes
    set +e
    local hook_output
    # shellcheck disable=SC2034
    if $VERBOSE; then
        verbose_log "Running install_shell_hook with output visible"
        hook_output=$(install_shell_hook "$current_shell" 2>&1)
        local hook_status=$?
        verbose_log "install_shell_hook output: $hook_output"
    else
        hook_output=$(install_shell_hook "$current_shell" 2>&1)
        local hook_status=$?
    fi
    verbose_log "install_shell_hook exit status: $hook_status"
    set -e

    case $hook_status in
        0)
            verbose_log "Shell integration succeeded"
            echo -e " ${GREEN}OK${NC}"
            ;;
        2)
            verbose_log "Shell integration already configured"
            echo -e " ${YELLOW}SKIP${NC} (already configured)"
            ;;
        *)
            verbose_log "Shell integration failed with status $hook_status"
            verbose_log "Hook output: $hook_output"
            echo -e " ${RED}FAILED${NC}"
            log "You can manually source the appropriate hook file from ${YELLOW}$CFG_DIR${NC}"
            exit 1
            ;;
    esac

    # 4) Final message
    verbose_log "Installation process completed"
    log "${GREEN}Installation completed successfully!${NC}"
    echo -e ""
    echo -e "Please restart your shell or run '${YELLOW}source ~/.${current_shell}rc${NC}' to activate ${BLUE}git-undo${NC}"
}

main "$@"
