#!/usr/bin/env bash
# Build script to generate standalone install/uninstall scripts
set -e

SCRIPT_DIR="$(dirname "$0")"
COLORS_FILE="$SCRIPT_DIR/colors.sh"
COMMON_FILE="$SCRIPT_DIR/common.sh"
BASH_HOOK_FILE="$SCRIPT_DIR/git-undo-hook.bash"
BASH_TEST_HOOK_FILE="$SCRIPT_DIR/git-undo-hook.test.bash"
ZSH_HOOK_FILE="$SCRIPT_DIR/git-undo-hook.zsh"
SRC_INSTALL="$SCRIPT_DIR/install.src.sh"
SRC_UNINSTALL="$SCRIPT_DIR/uninstall.src.sh"
SRC_UPDATE="$SCRIPT_DIR/update.src.sh"
OUT_INSTALL="$SCRIPT_DIR/../install.sh"
OUT_UNINSTALL="$SCRIPT_DIR/../uninstall.sh"
OUT_UPDATE="$SCRIPT_DIR/../update.sh"

echo "Building standalone scripts..."

# Function to encode a file as a base64 string for embedding
encode_hook_file() {
    local file="$1"
    local var_name="$2"
    echo "${var_name}='$(base64 < "$file" | tr -d '\n')'"
}

# Function to build a standalone script
build_script() {
    local src_file="$1"
    local out_file="$2"
    local script_name="$(basename "$out_file")"
    
    # echo "Building $script_name..."
    
    # Start with shebang and comment
    cat > "$out_file" << 'EOF'
#!/usr/bin/env bash
# This file is auto-generated by scripts/build.sh
# DO NOT EDIT - modify scripts/*.src.sh instead and run 'make buildscripts'
EOF
    
    # If building install.sh, add embedded hook files
    if [[ "$script_name" == "install.sh" ]]; then
        echo "" >> "$out_file"
        echo "# ── Embedded hook files ── that's a base64 of scripts/git-undo-hook.bash ────" >> "$out_file"
        encode_hook_file "$BASH_HOOK_FILE" "EMBEDDED_BASH_HOOK" >> "$out_file"
        encode_hook_file "$BASH_TEST_HOOK_FILE" "EMBEDDED_BASH_TEST_HOOK" >> "$out_file"
        encode_hook_file "$ZSH_HOOK_FILE" "EMBEDDED_ZSH_HOOK" >> "$out_file"
        echo "# ── End of embedded hook files ──────────────────────────────────────────────" >> "$out_file"
        echo "" >> "$out_file"
    fi
    
    # Process the source file line by line
    while IFS= read -r line; do
        # Skip the shebang in source file
        if [[ "$line" =~ ^#!/.* ]]; then
            continue
        fi
        
        # Replace the common.sh source line with actual content
        if [[ "$line" =~ source.*common\.sh ]]; then
            echo "# ── Inlined content from common.sh ──────────────────────────────────────────" >> "$out_file"
            
            # First inline colors.sh content (without shebang and without sourcing line)
            tail -n +2 "$COLORS_FILE" | grep -v '^#!/' >> "$out_file"
            tail -n +2 "$COMMON_FILE" | grep -v '^#!/' | grep -v 'source.*colors\.sh' | grep -v '^SCRIPT_DIR=' | grep -v '^#.*Source shared colors' >> "$out_file"
            
            echo "# ── End of inlined content ──────────────────────────────────────────────────" >> "$out_file"
        else
            echo "$line" >> "$out_file"
        fi
    done < "$src_file"
    
    # Make executable
    chmod +x "$out_file"
    echo "✓ Generated $out_file"
}

# Build all scripts
build_script "$SRC_INSTALL" "$OUT_INSTALL"
build_script "$SRC_UNINSTALL" "$OUT_UNINSTALL"
build_script "$SRC_UPDATE" "$OUT_UPDATE"

echo "✓ Build complete!" 